package main

import (
	"bytes"
	"fmt"
	"io"

	"golang.org/x/net/http2"
	"golang.org/x/net/http2/hpack"
)

func main() {
	raw := []byte{ /* Packet 73 */
		0x00, 0x00, 0x00, 0x04, 0x01, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x4a, 0x01, 0x04, 0x00, 0x00,
		0x00, 0x01, 0x83, 0x86, 0x45, 0x8d, 0x61, 0x36,
		0xd4, 0xbe, 0x3d, 0xfb, 0xf5, 0x89, 0x8d, 0x76,
		0x1f, 0xcf, 0xaf, 0x41, 0x8a, 0x08, 0x9d, 0x5c,
		0x0b, 0x81, 0x70, 0xdc, 0x0b, 0x6d, 0xb3, 0x5f,
		0x8f, 0x1d, 0x75, 0xd0, 0x62, 0x0d, 0x26, 0x3d,
		0x4c, 0x4d, 0x65, 0x64, 0xff, 0x75, 0x1e, 0xbf,
		0x40, 0x02, 0x74, 0x65, 0x86, 0x4d, 0x83, 0x35,
		0x05, 0xb1, 0x1f, 0x40, 0x89, 0x9a, 0xca, 0xc8,
		0xb2, 0x4d, 0x49, 0x4f, 0x6a, 0x7f, 0x85, 0x08,
		0x5f, 0x7d, 0xd1, 0x53,
	}

	framer := http2.NewFramer(nil, bytes.NewReader(raw))
	hpackDecoder := hpack.NewDecoder(4096, nil)

	for {
		frame, err := framer.ReadFrame()
		if err == io.EOF {
			break
		} else if err != nil {
			fmt.Println("failed to decode", err)
			break
		}

		fmt.Println(frame.Header().Type)

		if headerFrame, ok := frame.(*http2.HeadersFrame); ok {
			headers, err := hpackDecoder.DecodeFull(headerFrame.HeaderBlockFragment())
			if err != nil {
				fmt.Println("failed to decode header", err)
			} else {
				fmt.Println(headers)
			}
		}
	}
}
